________________________________________________________________________________		CS5004 Midterm V1 -- Silicon Valley -- Prof Mark			Administered October 16, 2025________________________________________________________________________________			      MIDTERM EXAM RULES________________________________________________________________________________				       This is a proctored, in-person exam. You may use your laptop, the internet,Canvas, existing Piazza threads (but do not post during the exam!), materialsincluding slides from class, and your own notes. However, please do not copyand paste code from other sources that you have not written yourself, whetherfrom a website or a generative AI tool. It is fine to look things up such asthe name of a Java builtin class or the syntax for calling a particularmethod, to jog your memory. Accessing your own solutions to previousassignments is also fine.Please do not discuss the contents of this exam with anyone except theinstructor or the TAs before, during, or after taking the exam. One ortwo clarification questions may be asked quietly. If the issue is ofsufficiently general interest, the instructor will share the questionand answer with everyone. Please allow AT LEAST 10 MINUTES near theend to commit and push your files to your GitHub repo, and upload theURL to Canvas, BEFORE the deadline. Late submissions will be severelypenalized, since taking extra time provides an unfair advantage relativeto other students.Modifying your code on GitHub after the deadline is NOT OK, even if Canvasreceived your URL on time. Both your pushed code and your Canvas-posted URLmust be on time.________________________________________________________________________________				 INSTRUCTIONS________________________________________________________________________________This exam provides starter code. Please download the ".zip" file,decompress it, and IMPORT the resulting folder hierarchy intoIntelliJ. Keep this "instructions.txt" file within the folder andcommit/push everything to your GitHub repo within a new folder withinCS5004 called midterm. There should be "src" and "test" sub-folders andrelated documents including a sub-folder containing diagrams. Keep a copyof the originals, in case you mess up and need to recover a file.Use this IntelliJ command:	File -> New Project From Existing Sourcesto import the entire folder into IntelliJ. You may ask a TA or theinstructor for help with this step in case you experience any difficulties.Most files are starter code requiring completion. This file includes placesbelow where you should answer questions referring to the other files.You will work on this exam entirely by editing files within thisproject. At the end, it will be critically important to accomplishthe following steps. These will take some time, since sometimes evenminor issues can interfere with the commit-push process. Allow aminimum of TEN minutes for your wrap-up procedure:  a. Commit this project, including any new files you may have added.  Be  sure that any edits you make to any files, including this one, are  included.  b. Push the project, so that your GitHub version matches the version  on your desktop. Check that everything matches!  c. Submit the URL for your submitted GitHub folder to Canvas, just as you  would with a homework. TAs will compare the Canvas submission date to  the most recent changes to your corresponding GitHub folder, so please  do not continue editing once you have posted your URL on Canvas.You will be working on pieces of an unfinished information system abouthousehold pets. You are not expected to complete a polished workingprogram; just address the aspects stated in these instructions. In somecases, it may feel challenging to test your work due to other files havingonly "stubbed out" bits of code. Do not be alarmed; that's often howsoftware engineering occurs. You may use your computer, your nodes,Canvas, Piazza, and the web (sparingly -- no copy/paste!). Do not use AIduring this exam.There are several tasks, totaling 100 points.1.[20 points] Study the diagram in shown in pets_diagram.png.Then, read each of the nine provided Java files in src. Writetop-of-file Javadocs for each of those files. Writing Javadocsfor all the individual methods is not required for this exam.2. [20 points] Find up to FIVE "bugs" total in these four files:   - AbstractShape.java (not counted: the compareTo method returns 0)   - Dog.java   - BirdTest.java   - PetLastVetVisitComparator   There may be more than five bugs, but you should report just five.   Observing that some code is missing or "stubbed out" does not count!   Multiple occurrences (or extremely similar bugs) DO NOT COUNT! IntelliJ's   yellow warnings also do not count. Insert extra lines immediately above   or below each bug to clearly mark and describe the issue, like this EXAMPLE:   //BUG (Example)   //Issue: Method is apt to divide by zero, but there is no try block [1 pt]   //Approach: Brief summary of proposed fix, for partial credit [+1 pt]   //Solution: Provide the corrected code for full credit [+1 pt]   If you provide corrected code, comment out the buggy code (don't delete it).2. [20 points] Implement the following missing or stubbed out code:    a. The compareTo method in AbstractPet.java (heavier pets are "greater")    b. All missing/unfinished methods in AbstractPet.java, INCLUDING toString.    c. Implement 2 other ways to sort pets without modifying Pet, AbstractPet,       or individual pet classes: one based on the pet's last visit to the Vet,       and one based on their name; you should illustrate TWO DIFFERENT ways       to use Comparator-style comparisons for uses with Collections.sort.    d. Tests (TWO assertions for each method) for AbstractPet (only)3. [22 points] Add an equals method (and hashCode method) to AbstractPet. It's unnecessary   for every instance variable to be equal. If the pet's name, owner, color, weight,   and age are equal, you might assume that they are equal. It is acceptable to use   getClass() in this special sort of situation, because you might not want to conclude   that a Dog and a Cat with the same name, owner, etc. are equal. (We try to avoid   using getClass when instanceof would suffice, otherwise.)4. Examine the Class Diagrams provided, and answer the   following questions, by typing in your responses after the ">>> " below.   4.1 [4 points] What is the main benefit of AbstractPet class in the Pets Diagram?    A. To break up the instance variables based on type of Pet    B. To reduce the number of methods that are visible to end users    C. To minimize redundant code when subclasses implement similar methods    D. All of the above    E. None of the above>>>4.1 - C    4.2 [4 points] What does the "#" sign  mean in the AbstractPet box on the diagram? Why does    this symbol even matter?    A. To make it clear that those variables must be ints, floats, or doubles    B. To indicate that those variables should not be accessible to subclasses    C. To indicate that those variables must be accessible to subclasses    D. The "#" sign was just an artistic convention by that particular author    E. None of the above>>>4.2 - C4.3 [4 points] In the nodes_diagram.png, what does the dark diamond arrowhead represent?    A. It represents a subclass relationship ("is-a")    B. It indicates that the top entity is more important than the bottom one    C. It represents composition or a "has-a" relationship    D. It indicates that the top entity is patented and/or copyrighted    E. None of the above>>>4.3 - C4.4 [6 points] Consider the "count" method as mentioned in nodes_diagram.png.    A. Write Java code to implement a count method for EmptyNode (type it here)>>>>>>@Overridepublic int count() {    return 0;}    B. Write Java code to implement a count method for ElementNode (type it here)>>>>>>>>>@Overridepublic int count() {    return 1 + rest.count();}